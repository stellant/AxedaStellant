// -----------------------------------------------------------------------------
//           $Copyright: (C) Copyright by Bayer Healthcare 2013. All rights reserved. $
// -----------------------------------------------------------------------------
// 
//  $Source: AxedaAgent/Agent Configuration Data Sources/EnterpriseProxy.cs $
//  $Revision: 1.1 $
//  $Date: 2012/09/12 14:43:39EDT $
//  $Author: MLHAY $
//  $ProjectName: g:/MKS_Files/Service_Engineering/ApplicationFramework/AxedaAgent/project.pj $
// 
// -----------------------------------------------------------------------------

namespace Medrad.ServiceEngineering.ApplicationFramework.Axeda.Agent
{
	using Medrad.ServiceEngineering.ApplicationFramework.Axeda.Agent;
    using System.Collections.Specialized;
    using System.Xml;

    /// <summary>
    /// Class Abstracts the Enterprise Proxy file generated by Axeda based on
    /// Solution #1801 from Axeda.
    /// </summary>
    internal class EnterpriseProxy
    {
        #region Constructors and Destructors

        /// <summary>
        /// Initializes a new instance of the <see cref="EnterpriseProxy" />
        /// class.
        /// </summary>
        /// <param name="proxyFilePath">The proxy file path.</param>
        public EnterpriseProxy(string proxyFilePath = "")
        {
            // This we'll initialize a collection of strings, which will be our de facto "xml" parsing.  
            // Axeda Files are not strong XML.  They use XML more or less as raw text file storage.  We'll do a two part
            // decode of these files, first, we'll read all of the values, then, we'll order based assign them to an object
            // to make manipulation easier.  
            var values = new StringCollection();
            if (string.IsNullOrEmpty(proxyFilePath))
            {
                proxyFilePath = AxedaFilePathConfiguration.GetFilePaths().EnterpriseProxyConfigPath;
            }

            using (XmlReader rdr = XmlReader.Create(proxyFilePath))
            {
                while (rdr.Read())
                {
                    // We're only concerned with text data.  If we find text, we'll just add it to our list.  
                    if (rdr.NodeType == XmlNodeType.Text)
                    {
                        // Axeda uses quotes to delimit strings, so we'll strip them before we add them to the collection. 
                        values.Add(rdr.Value.Replace("\"", string.Empty).Trim());
                    }
                }
            }

            // If we aren't able to read all of the elements, we will fail safe and not set any element values.  If everything 
            // works out though, we will be setting the values accordingly based on the index positions.  
            if (values.Count == (int)ElementPos.TotalElements)
            {
                // We'll do our string values first
                this.ServerAddress = values[(int)ElementPos.ServerAddress];
                this.ServerletName = values[(int)ElementPos.ServerletName];
                this.ProxyHttpAddress = values[(int)ElementPos.ProxyHttpAddress];
                this.ProxyHttpUserName = values[(int)ElementPos.ProxyHttpUserName];
                this.ProxyHttpEncryptedPassword = values[(int)ElementPos.ProxyHttpEncryptedPassword];
                this.ProxySocksAddress = values[(int)ElementPos.ProxySocksAddress];
                this.ProxySocksUserName = values[(int)ElementPos.ProxySocksUserName];
                this.ProxySocksEncryptedPassword = values[(int)ElementPos.ProxySocksEncryptedPassword];
                this.DatabaseName = values[(int)ElementPos.DatabaseName];

                // Next we'll do our integer values
                this.FileFormat = ConversionUtils.StrToInt(values[(int)ElementPos.FileFormat]);
                this.BaseIntervalBetweenRetries =
                    ConversionUtils.StrToInt(values[(int)ElementPos.BaseIntervalBetweenRetries]);
                this.RetryCount = ConversionUtils.StrToInt(values[(int)ElementPos.RetryCount]);
                this.MaxQueueSize = ConversionUtils.StrToInt(values[(int)ElementPos.MaxQueueSize]);
                this.ServerPortNumber = ConversionUtils.StrToInt(values[(int)ElementPos.ServerPortNumber]);
                this.RemoteWakeupPort = ConversionUtils.StrToInt(values[(int)ElementPos.RemoteWakeupPort]);
                this.PingRate = ConversionUtils.StrToInt(values[(int)ElementPos.PingRate]);
                this.FlushTimeout = ConversionUtils.StrToInt(values[(int)ElementPos.FlushTimeout]);
                this.MaxMessageSize = ConversionUtils.StrToInt(values[(int)ElementPos.MaxMessageSize]);
                this.ProxyHttpPortNumber = ConversionUtils.StrToInt(values[(int)ElementPos.ProxyHttpPortNumber]);
                this.ProxySocksPortNumber = ConversionUtils.StrToInt(values[(int)ElementPos.ProxySocksPortNumber]);
                this.MaxTrailingZeros = ConversionUtils.StrToInt(values[(int)ElementPos.MaxTrailingZeros]);
                this.HttpDebugLevel = ConversionUtils.StrToInt(values[(int)ElementPos.HttpDebugLevel]);
                this.HttpTimeout = ConversionUtils.StrToInt(values[(int)ElementPos.HttpTimeout]);

                // Now we'll convert our Boolean values
                this.ProxyHttpUsed = ConversionUtils.StrToBool(values[(int)ElementPos.ProxyHttpUsed]);
                this.ProxySocksUsed = ConversionUtils.StrToBool(values[(int)ElementPos.ProxySocksUsed]);
                this.LogOutgoingMessagesFlag = ConversionUtils.StrToBool(values[(int)ElementPos.LogOutgoingMessagesFlag]);
                this.LogBufferActivityFlag = ConversionUtils.StrToBool(values[(int)ElementPos.LogBufferActivityFlag]);
                this.SslAuthenticationFlag = ConversionUtils.StrToBool(values[(int)ElementPos.SslAuthenticationFlag]);
                this.EnableSslFlag = ConversionUtils.StrToBool(values[(int)ElementPos.EnableSslFlag]);
                this.PersistentConnectionFlag = ConversionUtils.StrToBool(values[(int)ElementPos.PresistentConnectionFlag]);
                this.UsesAutoProxy = ConversionUtils.StrToBool(values[(int)ElementPos.UsesAutoProxy]);
                this.UseBackupLink = ConversionUtils.StrToBool(values[(int)ElementPos.UseBackupLink]);

                // Finally we'll handle the "special" cases
                EncryptionType = ConversionUtils.StrToEncryptionType(values[(int)ElementPos.EncryptionType]);
                SslEncryptionLevel = ConversionUtils.StrToSslLevel(values[(int)ElementPos.SslEncryptionLevel]);
            }
        }

        #endregion

        #region Nested type: ElementPos

        /// <summary>
        /// Holds the position elements for the enterprise proxy file
        /// </summary>
        private enum ElementPos
        {
            /// <summary>
            /// Specific File Format Number
            /// </summary>
            FileFormat = 0,

            /// <summary>
            /// Axeda Server Address
            /// </summary>
            ServerAddress,

            /// <summary>
            /// Axeda Serverlet Name 
            /// </summary>
            ServerletName,

            /// <summary>
            /// Axeda Server Port Number 
            /// </summary>
            ServerPortNumber,

            /// <summary>
            /// Time Between Retries (in MS)
            /// </summary>
            BaseIntervalBetweenRetries,

            /// <summary>
            ///  Number of retries before failing    
            /// </summary>
            RetryCount,

            /// <summary>
            ///  Max size of the Axeda Queues
            /// </summary>
            MaxQueueSize,

            /// <summary>
            ///  Flag to indicate if outgoing messages will be logged
            /// </summary>
            LogOutgoingMessagesFlag,

            /// <summary>
            /// Flag to indicate if outgoing activity will be logged to a buffer
            /// </summary>
            LogBufferActivityFlag,

            /// <summary>
            /// Remote Wake Up Port 
            /// </summary>
            RemoteWakeupPort,

            /// <summary>
            /// The Rate the Agent will communicate with the server
            /// </summary>
            PingRate,

            /// <summary>
            /// The Timeout before flushing the Axeda Queues
            /// </summary>
            FlushTimeout,

            /// <summary>
            /// The Max Transportable Message Size
            /// </summary>
            MaxMessageSize,

            /// <summary>
            /// Current Encryption Type being utilized on the Axeda Agent
            /// </summary>
            EncryptionType,

            /// <summary>
            /// Indicates if an HTTP proxy is being used.
            /// </summary>
            ProxyHttpUsed,

            /// <summary>
            /// HTTP Proxy Address
            /// </summary>
            ProxyHttpAddress,

            /// <summary>
            /// HTTP Proxy Port Number
            /// </summary>
            ProxyHttpPortNumber,

            /// <summary>
            /// HTTP Proxy User Name
            /// </summary>
            ProxyHttpUserName,

            /// <summary>
            /// HTTP Proxy Encrypted Password
            /// </summary>
            ProxyHttpEncryptedPassword,

            /// <summary>
            /// Indicates if a SOCKS proxy is used
            /// </summary>
            ProxySocksUsed,

            /// <summary>
            /// SOCKS Proxy Address
            /// </summary>
            ProxySocksAddress,

            /// <summary>
            /// SOCKS Proxy Port
            /// </summary>
            ProxySocksPortNumber,

            /// <summary>
            /// SOCKS Proxy User Name
            /// </summary>
            ProxySocksUserName,

            /// <summary>
            /// Encrypted SOCKS Proxy Password
            /// </summary>
            ProxySocksEncryptedPassword,

            /// <summary>
            /// Indicates if the Axeda Agent should maintain a persistent connection to the Axeda Enterprise
            /// </summary>
            PresistentConnectionFlag,

            /// <summary>
            /// Indicates the current Axeda Communications SSL Level
            /// </summary>
            SslEncryptionLevel,

            /// <summary>
            /// Indicates if SSL Authentication is needed.
            /// </summary>
            SslAuthenticationFlag,

            /// <summary>
            /// The Axeda database name that the Agent should communicate 
            /// </summary>
            DatabaseName,

            /// <summary>
            /// Indicates whether the Axeda agent should use 
            /// </summary>
            UsesAutoProxy,

            /// <summary>
            ///  Indicates whether the agent should use the backup enterprise server
            /// </summary>
            UseBackupLink,

            /// <summary>
            /// Number of trailing zeros allowed in the axeda system
            /// </summary>
            MaxTrailingZeros,

            /// <summary>
            /// Indicates the HTTP Timeout duration for agents
            /// </summary>
            HttpTimeout,

            /// <summary>
            ///  Indicates if SSL is enabled
            /// </summary>
            EnableSslFlag,

            /// <summary>
            ///  The current debug level for the agents
            /// </summary>
            HttpDebugLevel,

            /// <summary>
            /// Total elements in the Axeda file structure.
            /// </summary>
            TotalElements
        }

        #endregion

        #region Public Properties

        /// <summary>
        /// Gets the file format value.
        /// </summary>
        public int? FileFormat { get; private set; }

        /// <summary>
        /// Gets or sets the DRM server IP address or hostname
        /// </summary>
        public string ServerAddress { get; set; }

        /// <summary>
        /// Gets the servlet name on DRM server
        /// </summary>
        public string ServerletName { get; private set; }

        /// <summary>
        /// Gets the port number on DRM server
        /// </summary>
        public int? ServerPortNumber { get; private set; }

        /// <summary>
        /// Gets the base interval used to calculate random delay between
        /// retries (in milliseconds)
        /// </summary>
        public int? BaseIntervalBetweenRetries { get; private set; }

        /// <summary>
        /// Gets the maximum retry count (obsolete, ignored by Axeda)
        /// </summary>
        public int? RetryCount { get; private set; }

        /// <summary>
        /// Gets maximum queue size (in bytes)
        /// </summary>
        public int? MaxQueueSize { get; private set; }

        /// <summary>
        /// Gets the "Log outgoing messages" flag
        /// </summary>
        public bool? LogOutgoingMessagesFlag { get; private set; }

        /// <summary>
        /// Gets the "Log buffer activity" flag
        /// </summary>
        public bool? LogBufferActivityFlag { get; private set; }

        /// <summary>
        /// Gets the remote wakeup port (obsolete, ignored by Axeda)
        /// </summary>
        public int? RemoteWakeupPort { get; private set; }

        /// <summary>
        /// Gets the ping rate (in milliseconds)
        /// </summary>
        public int? PingRate { get; private set; }

        /// <summary>
        /// Gets the flush timeout (obsolete, ignored by Axeda)
        /// </summary>
        public int? FlushTimeout { get; private set; }

        /// <summary>
        /// Gets the maximum message size
        /// </summary>
        public int? MaxMessageSize { get; private set; }

        /// <summary>
        /// Gets the encryption type
        /// </summary>
        public EncryptionType EncryptionType { get; private set; }

        /// <summary>
        /// Gets the HTTP proxy used status
        /// </summary>
        public bool? ProxyHttpUsed { get; private set; }

        /// <summary>
        /// Gets the HTTP proxy IP address or hostname
        /// </summary>
        public string ProxyHttpAddress { get; private set; }

        /// <summary>
        /// Gets the HTTP proxy port number
        /// </summary>
        public int? ProxyHttpPortNumber { get; private set; }

        /// <summary>
        /// Gets the HTTP proxy user name
        /// </summary>
        public string ProxyHttpUserName { get; private set; }

        /// <summary>
        /// Gets the HTTP proxy password (encrypted)
        /// </summary>
        public string ProxyHttpEncryptedPassword { get; private set; }

        /// <summary>
        /// Gets the SOCKS proxy used status
        /// </summary>
        public bool? ProxySocksUsed { get; private set; }

        /// <summary>
        /// Gets the SOCKS proxy IP address or hostname
        /// </summary>
        public string ProxySocksAddress { get; private set; }

        /// <summary>
        /// Gets the SOCKS proxy port number
        /// </summary>
        public int? ProxySocksPortNumber { get; private set; }

        /// <summary>
        /// Gets the SOCKS proxy user name
        /// </summary>
        public string ProxySocksUserName { get; private set; }

        /// <summary>
        /// Gets the SOCKS proxy password (encrypted)
        /// </summary>
        public string ProxySocksEncryptedPassword { get; private set; }

        /// <summary>
        /// Gets the persistent connection flag.
        /// </summary>
        public bool? PersistentConnectionFlag { get; private set; }

        /// <summary>
        /// Gets the Ssl encryption level.
        /// </summary>
        public SslEncryptionLevel SslEncryptionLevel { get; private set; }

        /// <summary>
        /// Gets the Ssl server authentication flag.
        /// </summary>
        public bool? SslAuthenticationFlag { get; private set; }

        /// <summary>
        /// Gets the name of the database.
        /// </summary>
        public string DatabaseName { get; private set; }

        /// <summary>
        /// Gets the "use AutoProxy feature" flag
        /// </summary>
        public bool? UsesAutoProxy { get; private set; }

        /// <summary>
        /// Gets the "use backup link" flag
        /// </summary>
        public bool? UseBackupLink { get; private set; }

        /// <summary>
        /// Gets the maximum trailing zeros
        /// </summary>
        public int? MaxTrailingZeros { get; private set; }

        /// <summary>
        /// Gets the HTTP timeout period.
        /// </summary>
        public int? HttpTimeout { get; private set; }

        /// <summary>
        /// Gets the "enable Ssl" flag.
        /// </summary>
        public bool? EnableSslFlag { get; private set; }

        /// <summary>
        /// Gets the HTTP debug level.
        /// </summary>
        public int? HttpDebugLevel { get; private set; }

        #endregion

        #region Public Methods and Operators

        /// <summary>
        /// Returns a <see cref="string" /> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="string" /> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return "Enterprise Proxy Information: \n" +
                   "\tFileFormat= " + this.FileFormat + "\n" +
                   "\tServerAddress= " + this.ServerAddress + "\n" +
                   "\tServerletName= " + this.ServerletName + "\n" +
                   "\tServerPortNumber= " + this.ServerPortNumber + "\n" +
                   "\tBaseIntervalBetweenRetries= " + this.BaseIntervalBetweenRetries + "\n" +
                   "\tRetryCount= " + this.RetryCount + "\n" +
                   "\tMaxQueueSize= " + this.MaxQueueSize + "\n" +
                   "\tLogOutgoingMessagesFlag= " + this.LogOutgoingMessagesFlag + "\n" +
                   "\tLogBufferActivityFlag= " + this.LogBufferActivityFlag + "\n" +
                   "\tRemoteWakeupPort= " + this.RemoteWakeupPort + "\n" +
                   "\tPingRate= " + this.PingRate + "\n" +
                   "\tFlushTimeout= " + this.FlushTimeout + "\n" +
                   "\tMaxMessageSize= " + this.MaxMessageSize + "\n" +
                   "\tEncryptionType= " + this.EncryptionType + "\n" +
                   "\tProxyHttpUsed= " + this.ProxyHttpUsed + "\n" +
                   "\tProxyHttpAddress= " + this.ProxyHttpAddress + "\n" +
                   "\tProxyHttpPortNumber= " + this.ProxyHttpPortNumber + "\n" +
                   "\tProxyHttpUserName= " + this.ProxyHttpUserName + "\n" +
                   "\tProxyHttpEncryptedPassword= " + this.ProxyHttpEncryptedPassword + "\n" +
                   "\tProxySocksUsed= " + this.ProxySocksUsed + "\n" +
                   "\tProxySocksAddress= " + this.ProxySocksAddress + "\n" +
                   "\tProxySocksPortNumber= " + this.ProxySocksPortNumber + "\n" +
                   "\tProxySocksUserName= " + this.ProxySocksUserName + "\n" +
                   "\tProxySocksEncryptedPassword= " + this.ProxySocksEncryptedPassword + "\n" +
                   "\tPersistentConnectionFlag= " + this.PersistentConnectionFlag + "\n" +
                   "\tSslEncryptionLevel= " + this.SslEncryptionLevel + "\n" +
                   "\tSslAuthenticationFlag= " + this.SslAuthenticationFlag + "\n" +
                   "\tDatabaseName= " + this.DatabaseName + "\n" +
                   "\tUsesAutoProxy= " + this.UsesAutoProxy + "\n" +
                   "\tUseBackupLink= " + this.UseBackupLink + "\n" +
                   "\tMaxTrailingZeros= " + this.MaxTrailingZeros + "\n" +
                   "\tHttpTimeout= " + this.HttpTimeout + "\n" +
                   "\tEnableSslFlag= " + this.EnableSslFlag + "\n" +
                   "\tHttpDebugLevel= " + this.HttpDebugLevel + "\n";
        }

        #endregion
    }
}